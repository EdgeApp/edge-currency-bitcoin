{"version":3,"file":"index.js","sources":["../src/utils/require.js","../src/utils/uintArray.js","../src/utils/hash.js","../src/utils/base.js","../src/networks/baseInfo.js","../src/networks/bitcoin.js","../src/core/networkInfo.js","../src/utils/formatter.js","../src/utils/secp256k1.js","../src/core/privateKey.js","../src/hd/hdKey.js","../src/hd/common.js","../src/utils/utils.js","../src/hd/path.js","../src/hd/private.js","../src/hd/public.js","../src/utils/persister.js","../index.js"],"sourcesContent":["const lazyHandler = activeModule => ({\n  get: (target, prop, receiver) => {\n    // If already loaded return the loaded module\n    if (activeModule) return activeModule[prop]\n    // Try to inject the loaded module\n    if (prop === 'inject') {\n      return loadedModule => {\n        activeModule = loadedModule\n        for (const prop in target) {\n          target[prop].inject(activeModule[prop])\n        }\n      }\n    }\n    // Create a new child proxy if this prop not yet exists\n    if (!target[prop]) {\n      target[prop] = new Proxy(function (...args) {\n        if (!activeModule) target()\n        return activeModule[prop](...args)\n      }, lazyHandler())\n    }\n    return target[prop]\n  }\n})\n\nexport const lazify = unsafeModule => {\n  const parentModule = function (injectedModule = {}, loadUnsafe = true) {\n    const defaultModule = loadUnsafe ? unsafeModule() : {}\n    const loadedModule = Object.assign(defaultModule, injectedModule)\n    parentProxy.inject(loadedModule)\n  }\n  const parentProxy = new Proxy(parentModule, lazyHandler())\n  return parentProxy\n}\n","// @flow\n\nexport const isHexString = (hex: string) =>\n  typeof hex === 'string' && /^[0-9a-f]*$/i.test(hex)\n\nexport const toUint8Array = (hexString: string): Uint8Array => {\n  if (!isHexString(hexString)) {\n    throw new Error(`${hexString} is Not a Hex string`)\n  }\n  if (hexString.length % 2 !== 0) hexString = `0${hexString}`\n  const hex = hexString.match(/.{1,2}/g) || []\n  const bytes = hex.map(byte => parseInt(byte, 16))\n  return new Uint8Array(bytes)\n}\n\nexport const fromUint8Array = (bytes: Uint8Array): string =>\n  bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '')\n","// @flow\n\nimport { type Hashes } from '../../types/utils.js'\nimport { lazify } from './require.js'\nimport { fromUint8Array, toUint8Array } from './uintArray.js'\n\nexport const hashjs: Hashes<Uint8Array> = (lazify(() =>\n  require('hash.js')\n): any)\n\nexport const digest = (hash: Function) => (data: string) => {\n  const uintArray = toUint8Array(data)\n  const rawRes = hash()\n    .update(uintArray)\n    .digest()\n  const resArray = new Uint8Array(rawRes)\n  return fromUint8Array(resArray)\n}\n\nexport const digestHmac = (hmac: Function, hash: Function) => (\n  key: string,\n  data: string\n) => {\n  const uintKey = toUint8Array(key)\n  const hmacHash = () => hmac(hash, uintKey)\n  return digest(hmacHash)(data)\n}\n\nexport const sha256 = digest(hashjs.sha256)\nexport const sha512 = digest(hashjs.sha512)\nexport const ripemd160 = digest(hashjs.ripemd160)\nexport const sha512Hmac = digestHmac(hashjs.hmac, hashjs.sha512)\n\nexport const hash256 = (data: string) => sha256(sha256(data))\nexport const hash160 = (data: string) => ripemd160(sha256(data))\n","// @flow\n\nimport { Buffer } from 'buffer'\n\nimport basex from 'base-x'\n\nimport {\n  type Alphabet,\n  type BaseCheck,\n  type BaseDecoder,\n  type Bases,\n  type HashFunction\n} from '../../types/utils.js'\nimport { hash256 } from './hash.js'\n\n// The default ALPHABETS, the name of the base codec will be the alphabet's length\nexport const ALPHABETS: Array<Alphabet> = [\n  '01',\n  '01234567',\n  '0123456789a',\n  '0123456789abcdef',\n  '0123456789ABCDEFGHJKMNPQRSTVWXYZ',\n  '0123456789abcdefghijklmnopqrstuvwxyz',\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',\n  '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n]\n\nexport const createCheckSumBase = (\n  base: BaseDecoder,\n  hashFunc?: HashFunction<string>\n): BaseDecoder => ({\n  encode: (hexStr: string): string => {\n    const checksum = (hashFunc || hash256)(hexStr)\n    const checkHex = `${hexStr}${checksum.slice(0, 8)}`\n    return base.encode(checkHex)\n  },\n  decode: (baseString: string): string => {\n    const hexStr = base.decode(baseString)\n    const payload = hexStr.slice(0, -8)\n    const newChecksum = (hashFunc || hash256)(payload)\n    const checksum = hexStr.slice(-8)\n    if (newChecksum.startsWith(checksum)) return payload\n    throw new Error('Invalid checksum')\n  }\n})\n\nexport const createHexEncoder = (\n  base: BaseDecoder,\n  hashFunc?: HashFunction<string>\n): BaseCheck => {\n  const newBase = { ...base }\n  const encode: (buf: Buffer) => string = newBase.encode\n  const decode: (str: string) => Buffer = newBase.decode\n  newBase.encode = a => encode(Buffer.from(a, 'hex'))\n  newBase.decode = a => decode(a).toString('hex')\n  return { ...newBase, check: createCheckSumBase(newBase, hashFunc) }\n}\n\nexport const base: Bases = ALPHABETS.reduce((decoders, alphabet) => {\n  const baseDecoder = createHexEncoder(basex(alphabet))\n  return { ...decoders, [alphabet.length]: baseDecoder }\n}, {})\n","// @flow\n\nimport { type NetworkInfo, type HDPathsSetting } from '../../types/core'\nimport { base } from '../utils/base.js'\nimport { hash256 } from '../utils/hash.js'\n\n// TODO - Actually get bech32\nconst bech32 = base['58'].check\nconst base58 = base['58'].check\n\nconst HDPaths: HDPathsSetting = {\n  '32': {\n    scriptType: 'P2PKH',\n    xpriv: { prefix: 0x0488ade4, stringPrefix: 'xprv', decoder: { ...base58, base: 'xprv' } },\n    xpub: { prefix: 0x0488b21e, stringPrefix: 'xpub', decoder: { ...base58, base: 'xpub' } },\n    address: { prefix: 0x80, stringPrefix: '1', decoder: { ...base58, base: '1' } }\n  },\n  '44': {\n    scriptType: 'P2PKH',\n    xpriv: { prefix: 0x0488ade4, stringPrefix: 'xprv', decoder: { ...base58, base: 'xprv' } },\n    xpub: { prefix: 0x0488b21e, stringPrefix: 'xpub', decoder: { ...base58, base: 'xpub' } },\n    address: { prefix: 0x80, stringPrefix: '1', decoder: { ...base58, base: '1' } }\n  },\n  '49': {\n    scriptType: 'P2WPKH-P2SH',\n    xpriv: { prefix: 0x049d7878, stringPrefix: 'yprv', decoder: base58 },\n    xpub: { prefix: 0x049d7cb2, stringPrefix: 'ypub', decoder: base58 },\n    address: { prefix: 0x05, stringPrefix: '3', decoder: base58 }\n  },\n  '84': {\n    scriptType: 'P2WPKH',\n    xpriv: { prefix: 0x04b2430c, stringPrefix: 'zprv', decoder: base58 },\n    xpub: { prefix: 0x04b24746, stringPrefix: 'zpub', decoder: base58 },\n    address: { prefix: -1, stringPrefix: 'bc', decoder: bech32 }\n  }\n}\n\nexport const main: NetworkInfo = {\n  coinType: 0,\n  wif: {\n    prefix: 0x80,\n    stringPrefix: '1',\n    decoder: base['58'].check\n  },\n  HDPaths,\n  DefaultHDPath: 44,\n  txHash: hash256,\n  sigHash: (str: Buffer) => Buffer.from(hash256(str.toString('hex')), 'hex')\n}\n","// @flow\n\nexport const main = { DefaultHDPath: 84 }\n\nexport const testnet = {\n  coinType: 1,\n  wif: 0xef,\n  HDPaths: {\n    '32': {\n      xpriv: {\n        prefix: 0x04358394,\n        stringPrefix: 'tprv'\n      },\n      xpub: {\n        prefix: 0x043587cf,\n        stringPrefix: 'tpub'\n      },\n      address: 0x6f\n    },\n    '44': {\n      xpriv: {\n        prefix: 0x04358394,\n        stringPrefix: 'tprv'\n      },\n      xpub: {\n        prefix: 0x043587cf,\n        stringPrefix: 'tpub'\n      },\n      address: 0x6f\n    },\n    '49': {\n      xpriv: {\n        prefix: 0x04358394,\n        stringPrefix: 'tprv'\n      },\n      xpub: {\n        prefix: 0x043587cf,\n        stringPrefix: 'tpub'\n      },\n      address: 0xc4\n    },\n    '84': {\n      xpriv: {\n        prefix: 0x04358394,\n        stringPrefix: 'tprv'\n      },\n      xpub: {\n        prefix: 0x043587cf,\n        stringPrefix: 'tpub'\n      },\n      address: 'tb'\n    }\n  }\n}\n","// @flow\nimport { type BaseDecoder } from '../../types/utils.js'\nimport {\n  type HDPathSetting,\n  type NetworkInfo,\n  type NetworkInfos,\n  type NewNetworks\n} from '../../types/core.js'\nimport { main } from '../networks/baseInfo.js'\nimport * as Networks from '../networks/networks.js'\n\nexport const createInfo = (info: $Shape<NetworkInfo>): NetworkInfo => {\n  const newNetwork: NetworkInfo = ({}: any)\n\n  for (const set in main) {\n    const mainSet = main[set]\n    const infoSet = info[set]\n\n    if (Array.isArray(mainSet)) {\n      newNetwork[set] = (infoSet || [])\n        .concat(mainSet)\n        .filter((v, i, s) => s.indexOf(v) === i)\n    } else if (typeof mainSet === 'object') {\n      newNetwork[set] = { ...mainSet, ...(infoSet || {}) }\n    } else if (typeof infoSet !== 'undefined') {\n      newNetwork[set] = infoSet\n    } else newNetwork[set] = mainSet\n  }\n\n  return newNetwork\n}\n\nexport const createNetworks = (newInfos: NewNetworks) => {\n  const networks = { main }\n  for (const network in newInfos) {\n    const infos = newInfos[network]\n    for (const networkType in infos) {\n      const partialInfo = infos[networkType]\n      let name = network\n      if (networkType !== 'main') name += networkType.toLowerCase()\n      networks[name] = createInfo(partialInfo)\n    }\n  }\n  return networks\n}\n\nexport const networks: NetworkInfos = createNetworks(Networks)\n\nexport const addNetworks = (newInfos: NewNetworks) =>\n  Object.assign(networks, createNetworks(newInfos))\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\n// /////////////////\nexport const getHDSetting = (value: any, network?: string): HDPathSetting => {\n  // If no network is specified, check all available networks\n  if (!network) {\n    for (const network in networks) {\n      try {\n        return getHDSetting(value, network)\n      } catch (e) {}\n    }\n    throw new Error('Unknown prefix')\n  }\n\n  const { HDPaths } = networks[network]\n  for (const purpose in HDPaths) {\n    const hdPath = HDPaths[purpose]\n    for (const key in hdPath) {\n      const setting = hdPath[key]\n      // checking if address that has legacy\n      if (Array.isArray(setting)) {\n        return setting.find(\n          ({ prefix, stringPrefix }) =>\n            prefix === value || stringPrefix === value\n        )\n      }\n\n      // checking if xpub, xpriv, or address\n      if (\n        typeof setting === 'object' &&\n        (setting.prefix === value || setting.stringPrefix === value)\n      ) {\n        return hdPath\n      }\n\n      // if scriptType or purpose\n      if (setting === value) return hdPath\n    }\n  }\n  throw new Error(`Wrong value: ${value} for network: ${network}`)\n}\n\nexport const getDecoder = (network: string, value: any): BaseDecoder => {\n  const hdPath = getHDSetting(value, network)\n  for (const key in hdPath) {\n    const decoder = hdPath[key]\n\n    if (Array.isArray(decoder)) {\n      return decoder.find(\n        ({ prefix, stringPrefix }) =>\n          prefix === value || stringPrefix === value\n      )\n    }\n\n    if (decoder.prefix === value || decoder.stringPrefix === value) {\n      return decoder.decoder\n    }\n  }\n  throw new Error(`Wrong value: ${value} for network: ${network}`)\n}\n","// @flow\n\nimport { type FunctionFormatterOptions } from '../../types/utils.js'\nimport { fromUint8Array, toUint8Array } from './uintArray.js'\n\nexport const formatFunction = (\n  func: Function,\n  opts?: FunctionFormatterOptions = {}\n) => {\n  const { numParams = 1, encoder, results = [], sync } = opts\n  const { input = toUint8Array, output = fromUint8Array } = encoder || {}\n\n  const encode = (i: number, cps = a => a) => {\n    if (!i--) return cps\n    const newCps = (p: any) => {\n      p[i] = input(p[i])\n      return cps(p)\n    }\n    return encode(i, newCps)\n  }\n\n  const paramEncoder = encode(numParams)\n\n  let encodeResult = (res: any) => output(res)\n  if (!results) {\n    encodeResult = (res: any) => res\n  } else if (results.length) {\n    encodeResult = (res: any) => {\n      for (const param of results) {\n        res[param] = output(res[param])\n      }\n      return res\n    }\n  }\n\n  let waitResult = async (res: any) => {\n    res = await res\n    return encodeResult(res)\n  }\n  if (sync) waitResult = (res: any) => encodeResult(res)\n\n  return (...params: any): any => {\n    const result = func(...paramEncoder(params))\n    return waitResult(result)\n  }\n}\n\nexport const formatByteSize = (\n  originalByteSize: number,\n  newByteSize: number,\n  pad: boolean = originalByteSize > newByteSize\n) => (data: Array<number>) => {\n  let acc = 0\n  let bits = 0\n  const ret = []\n  const maxNum = (1 << newByteSize) - 1\n  for (let p = 0; p < data.length; ++p) {\n    const value = data[p]\n    if (value < 0 || value >> originalByteSize !== 0) {\n      throw new Error('Wrong bit value')\n    }\n    acc = (acc << originalByteSize) | value\n    bits += originalByteSize\n    while (bits >= newByteSize) {\n      bits -= newByteSize\n      ret.push((acc >> bits) & maxNum)\n    }\n  }\n  if (pad && bits > 0) {\n    ret.push((acc << (newByteSize - bits)) & maxNum)\n  } else if (\n    bits >= originalByteSize ||\n    (acc << (newByteSize - bits)) & maxNum\n  ) {\n    throw new Error('Wrong bit value')\n  }\n  return ret\n}\n","// @flow\n\nimport { type Secp256k1 } from '../../types/utils.js'\nimport { formatFunction } from './formatter.js'\nimport { lazify } from './require.js'\n\nexport const secp256k1: Secp256k1<Uint8Array> = (lazify(() =>\n  require('secp256k1')\n): any)\n\nconst encoder = {\n  input: a => Buffer.from(a, 'hex'),\n  output: a => a.toString('hex')\n}\n\nexport const publicKeyCreate = formatFunction(secp256k1.publicKeyCreate, {\n  encoder\n})\nexport const signatureNormalize = formatFunction(secp256k1.signatureNormalize, {\n  encoder\n})\nexport const signatureExport = formatFunction(secp256k1.signatureExport, {\n  encoder\n})\nexport const privateKeyTweakAdd = formatFunction(secp256k1.privateKeyTweakAdd, {\n  encoder,\n  numParams: 2\n})\nexport const publicKeyTweakAdd = formatFunction(secp256k1.publicKeyTweakAdd, {\n  encoder,\n  numParams: 2\n})\nexport const verify = formatFunction(secp256k1.verify, {\n  encoder,\n  numParams: 3,\n  results: null\n})\nexport const signature = formatFunction(secp256k1.sign, {\n  encoder,\n  numParams: 2,\n  results: ['signature']\n})\n\nexport const sign = (message: string, privateKey: string) =>\n  signature(message, privateKey)\n    .then(({ signature }) => signature)\n    .then(signatureNormalize)\n    .then(signatureExport)\n","// @flow\n\nimport { networks } from './networkInfo.js'\nimport {\n  publicKeyCreate,\n  sign as Sign,\n  verify as Verify\n} from '../../src/utils/secp256k1.js'\n\nexport const fromWIF = (\n  wif: string,\n  network: string = 'main'\n): { privateKey: string, compress: boolean } => {\n  const { prefix, decoder } = networks[network].wif\n  const keyHex = decoder.decode(wif)\n  if (parseInt(keyHex.slice(0, 2), 16) !== prefix) {\n    throw new Error(\n      `Unknown key prefix ${keyHex.slice(0, 2)} for network ${network}`\n    )\n  }\n  const privateKey = keyHex.slice(2, 66)\n  let compress = false\n  if (keyHex.length >= 68) {\n    if (parseInt(keyHex.slice(66, 68), 16) !== 1) {\n      throw new Error(`Unknown compression flag ${keyHex.slice(66, 68)}`)\n    }\n    compress = true\n  }\n  return { privateKey, compress }\n}\n\nexport const toWIF = (\n  privateKey: string,\n  network: string = 'main',\n  compress: boolean = true\n): string => {\n  if (privateKey.length !== 64) throw new Error(`Wrong key length`)\n  const { prefix, decoder } = networks[network].wif\n  const prefixStr = prefix.toString(16)\n  const compressFlag = compress ? '01' : ''\n  const hexKey = `${prefixStr}${privateKey}${compressFlag}`\n  return decoder.encode(hexKey)\n}\n\nexport const toPublic = async (\n  privateKey: string,\n  compress: boolean = true\n): Promise<string> => publicKeyCreate(privateKey, compress)\n\nexport const toSignature = async (privateKey: string, msg: string): Promise<string> => Sign(msg, privateKey)\n\nexport const verify = async (\n  msg: string,\n  signature: string,\n  publicKey?: string,\n  privateKey?: string\n): Promise<Boolean> => {\n  if (!publicKey) {\n    if (!privateKey) throw new Error('Cannot verify without keys.')\n    publicKey = await publicKeyCreate(privateKey, true)\n  }\n  const verified = await Verify(msg, signature, publicKey)\n  return verified\n}\n","// // @flow\n\n// import {\n//   type ExtendedKey,\n//   type HDKey\n// } from '../../types/hd.js'\n\n// import * as Private from './private.js'\n// import * as Public from './public.js'\n// import { fromNumber, toNumber } from './path.js'\n\n// // export const fromExtendedKey\n// // export const fromSeed\n// // export const fromHex\n// // export const fromString\n// // export const fromIndex\n// // export const fromPath\n// // export const toHex\n// // export const toString\n// // export const toPublic\n\n// export const fromHDKey = (hdKey: $Shape<HDKey>, network?: string): HDKey => {\n//   const { path: parentPath = [] } = hdPath || {}\n//   let indexStr = 'm'\n\n//   const path = [...parentPath]\n//   if (keyPair.depth) {\n//     indexStr = fromNumber(keyPair.childNumber)\n//   }\n\n//   if (path[0] !== 'm') path.unshift('m')\n//   if (path.length === keyPair.depth) {\n//     path.push(indexStr)\n//   }\n//   if (path.length !== keyPair.depth + 1) {\n//     throw new Error('Wrong path depth for key')\n//   }\n//   if (path[path.length - 1] !== indexStr) {\n//     throw new Error('Wrong index for key')\n//   }\n\n//   const hdKey: HDKey = { ...keyPair, path, children: {} }\n\n//   return hdKey\n// }\n\n// export const fromExtendedKey = (\n//   keyPair: ExtendedKey,\n//   hdPath?: HDPath\n// ): HDKey => {\n//   const { path: parentPath = [] } = hdPath || {}\n//   let indexStr = 'm'\n\n//   const path = [...parentPath]\n//   if (keyPair.depth) {\n//     indexStr = fromNumber(keyPair.childNumber)\n//   }\n\n//   if (path[0] !== 'm') path.unshift('m')\n//   if (path.length === keyPair.depth) {\n//     path.push(indexStr)\n//   }\n//   if (path.length !== keyPair.depth + 1) {\n//     throw new Error('Wrong path depth for key')\n//   }\n//   if (path[path.length - 1] !== indexStr) {\n//     throw new Error('Wrong index for key')\n//   }\n\n//   const hdKey: HDKey = { ...keyPair, path, children: {} }\n\n//   return hdKey\n// }\n\n// export const fromSeed = async (\n//   seed: string,\n//   network?: string\n// ): Promise<HDKey> => {\n//   const privateKey = Private.fromSeed(seed)\n//   const { publicKey } = await Private.toPublic(privateKey, network)\n//   return { ...privateKey, publicKey, children: {} }\n// }\n\n// export const fromParent = async (\n//   parentKey: HDKey,\n//   index: Index,\n//   network?: string\n// ): Promise<HDKey> => {\n//   let child\n//   const indexNum = toNumber(index)\n//   if (parentKey.privateKey) {\n//     child = await Private.toChild({ ...parentKey }, indexNum)\n//   } else {\n//     child = await Public.toChild({ ...parentKey }, indexNum)\n//   }\n\n//   const childHDPath = {\n//     ...parentKey,\n//     path: [...parentKey.path, index]\n//   }\n//   // Create an HD key from the ExtendedKey\n//   return fromExtendedKey(child, childHDPath)\n// }\n\n// export const fromPath = async (\n//   parentKeys: HDKey,\n//   hdPath: HDPath,\n//   network?: string\n// ): Promise<HDKey> => {\n//   // Get the deepest possible parent for this key\n//   const parent = getParentKey(parentKeys, hdPath.path)\n//   // Set the starting derivation key to be the parent key from before\n//   let childHDKey = parent.key\n\n//   while (parent.path.length) {\n//     // Get next child key\n//     const index = parent.path.shift()\n//     const childKey = await fromParent(childHDKey, index, network)\n\n//     // Add the new key to the current parent key and change the pointer\n//     childHDKey.children[index] = childKey\n//     childHDKey = childKey\n//   }\n\n//   return parentKeys\n// }\n\n// export const fromPaths = async (\n//   parentKey: HDKey | string,\n//   hdPaths: Array<HDPath>,\n//   network?: string\n// ): Promise<HDKey> => {\n//   // If we get a seed create a master hd key from it\n//   if (typeof parentKey === 'string') {\n//     parentKey = await fromSeed(parentKey, network)\n//   }\n\n//   // Create All missing key paths\n//   for (const hdPath of hdPaths) {\n//     parentKey = await fromPath(parentKey, hdPath)\n//   }\n\n//   return parentKey\n// }\n\n// export const fromString = (\n//   extendedKey: string,\n//   hdPath?: HDPath,\n//   network?: string\n// ): HDKey => {\n//   let xKey\n//   try {\n//     xKey = Private.fromString(extendedKey, network)\n//   } catch (e) {\n//     xKey = Public.fromString(extendedKey, network)\n//   }\n//   return fromExtendedKey(xKey, hdPath)\n// }\n\n// export const getParentKey = (\n//   parentKey: HDKey,\n//   path: Path\n// ): { key: HDKey, path: Path } => {\n//   const tempPath = [...path]\n//   tempPath.shift()\n//   while (parentKey.children[tempPath[0]] && tempPath.length) {\n//     parentKey = parentKey.children[tempPath.shift()]\n//   }\n//   return { key: parentKey, path: tempPath }\n// }\n\n// export const getKey = (parentKey: HDKey, path: Path): HDKey | null => {\n//   const tempPath = [...path]\n//   tempPath.shift()\n//   while (parentKey && tempPath.length) {\n//     parentKey = parentKey.children[tempPath.shift()]\n//   }\n//   return parentKey\n// }\n","// @flow\n\nimport { type ExtendedData } from '../../types/hd.js'\nimport { getHDSetting } from '../core/networkInfo.js'\n\nexport const HARDENED = 0x80000000\nexport const SEED = '426974636f696e2073656564'\nexport const MAX_INDEX = 0xffffffff\nexport const MAX_DEPTH = 0xff\nexport const TWEAK_OUT_OF_RANGE_ERROR = 'tweak out of range'\nexport const XKEY_DEFAULTS = {\n  childNumber: 0,\n  parentFingerPrint: 0,\n  depth: 0\n}\n\nexport const dataToHex = (data: ExtendedData): string =>\n  data.version.toString(16).padStart(8, '0') +\n  data.depth.toString(16).padStart(2, '0') +\n  data.parentFingerPrint.toString(16).padStart(8, '0') +\n  data.childNumber.toString(16).padStart(8, '0') +\n  data.chainCode\n\nexport const dataFromHex = (keyHex: string, network?: string): ExtendedData => {\n  // Check the entire hex length\n  if (keyHex.length !== 156) throw new Error('Wrong key length')\n\n  // Check that the key prefix matches the network's prefix if given a network\n  const version = parseInt(keyHex.slice(0, 8), 16)\n  if (network) {\n    const setting = getHDSetting(version, network)\n    if (!setting) throw new Error('Wrong extended key version for network')\n  }\n  return {\n    version,\n    depth: parseInt(keyHex.slice(9, 10), 16),\n    parentFingerPrint: parseInt(keyHex.slice(10, 18), 16),\n    childNumber: parseInt(keyHex.slice(18, 26), 16),\n    chainCode: keyHex.slice(26, 90)\n  }\n}\n","// @flow\n\nexport const isNumeric = (str: string) => /^-{0,1}\\d+$/.test(str)\n","// @flow\n\nimport { type HDPath } from '../../types/hd.js'\nimport { HARDENED, MAX_INDEX } from './common.js'\nimport { isNumeric } from '../utils/utils.js'\n\nexport const fromNumber = (index: number, harden: boolean = false): string => {\n  if (index > MAX_INDEX) throw new Error(`Index out of range: ${index}`)\n  // If it's a harden index, we need to set the flag and normalize the index\n  if (index >= HARDENED) {\n    harden = true\n    index = index - HARDENED\n  }\n  return harden ? `${index}'` : `${index}`\n}\n\nexport const toNumber = (index: string): number => {\n  // Check for hardened flag\n  const hardened = index[index.length - 1] === '\\''\n  // If hardened, we need to remove the harden flag\n  if (hardened) index = index.slice(0, -1)\n  // Index must be a number\n  if (!isNumeric(index)) throw new Error(`Index must be a number: ${index}`)\n  let indexNumber = parseInt(index)\n  // If hardened, we need to add the HARDENED param to the index\n  if (hardened) indexNumber += HARDENED\n\n  if (indexNumber > MAX_INDEX) throw new Error(`Index out of range: ${indexNumber}`)\n  return indexNumber\n}\n\nexport const toString = (path: HDPath): string => {\n  try {\n    return 'm/' + path.map(a => fromNumber(a)).join('/')\n  } catch (e) {\n    e.message = `Bad path: ${JSON.stringify(path)}\\n\\t${e.message}`\n    throw e\n  }\n}\n\nexport const fromString = (path: string, root: string = 'm'): HDPath => {\n  try {\n    const pathArr = path.split('/')\n    const pathRoot = pathArr.shift()\n    if (pathRoot !== root) throw new Error(`Unknown path root: '${pathRoot}', expected: '${root}'`)\n    return pathArr.map(toNumber)\n  } catch (e) {\n    e.message = `Bad path: ${path}\\n\\t${e.message}`\n    throw e\n  }\n}\n","// @flow\n\nimport { getHDSetting, getDecoder } from '../core/networkInfo.js'\nimport {\n  type HDPath,\n  type ExtendedPrivateKey,\n  type ExtendedPublicKey\n} from '../../types/hd.js'\nimport { dataFromHex, dataToHex, XKEY_DEFAULTS, HARDENED, SEED, MAX_INDEX, MAX_DEPTH, TWEAK_OUT_OF_RANGE_ERROR } from './common.js'\nimport { sha512Hmac, hash160 } from '../utils/hash.js'\nimport * as Path from './path.js'\nimport { toPublic as toPublicKey } from '../core/privateKey.js'\nimport { privateKeyTweakAdd } from '../utils/secp256k1.js'\n\nexport const fromPrivate = (key: $Shape<ExtendedPrivateKey>, network?: string): ExtendedPrivateKey => {\n  const { privateKey, chainCode } = key\n  if (!privateKey) throw new Error('Missing private key')\n  if (!chainCode) return fromSeed(privateKey)\n  const fullKey = { ...XKEY_DEFAULTS, ...key }\n  if (typeof fullKey.version !== 'number') {\n    const { xpriv: { prefix } } = getHDSetting('xprv', network)\n    fullKey.version = prefix\n  }\n  return fullKey\n}\n\nexport const fromSeed = (\n  seed: string,\n  network?: string,\n  version: string = 'xprv'\n): ExtendedPrivateKey => {\n  const hash = sha512Hmac(SEED, seed)\n  const { xpriv: { prefix } } = getHDSetting(version, network)\n  if (typeof prefix !== 'number') throw new Error('')\n  return fromPrivate({\n    privateKey: hash.slice(0, 64),\n    chainCode: hash.slice(64, 128),\n    version: prefix\n  }, network)\n}\n\nexport const fromHex = (keyHex: string, network?: string): ExtendedPrivateKey => {\n  // Get the byte which tells us what type of key we're expecting\n  const headerByte = parseInt(keyHex.slice(90, 92), 16)\n  if (headerByte !== 0) throw new Error('Wrong private key header')\n\n  return {\n    privateKey: keyHex.slice(92, 156),\n    ...dataFromHex(keyHex, network)\n  }\n}\n\nexport const fromString = (\n  xKey: string,\n  network: string = 'main'\n): ExtendedPrivateKey => {\n  const keyHex = getDecoder(network, xKey.slice(0, 4)).decode(xKey)\n  return fromHex(keyHex, network)\n}\n\nexport const fromIndex = async (\n  key: ExtendedPrivateKey,\n  index: number,\n  publicKey?: string,\n  hardended: boolean = false\n): Promise<ExtendedPrivateKey> => {\n  try {\n    const { depth, version, privateKey, chainCode } = key\n    if (index > MAX_INDEX) throw new Error('Index out of range.')\n    if (depth >= MAX_DEPTH) throw new Error('Depth too high.')\n    publicKey = publicKey || await toPublicKey(privateKey, true)\n\n    // If the index is non-hardended, set 'tweakKey' to be the publicKey, otherwise the privateKey\n    let tweakKey = index < HARDENED || hardended ? publicKey : `00${privateKey}`\n    tweakKey += index.toString(16).padStart(8, '0')\n    const hash = sha512Hmac(chainCode, tweakKey)\n\n    const childKey = await privateKeyTweakAdd(privateKey, hash.slice(0, 64))\n    const parentFingerPrint = publicKey ? hash160(publicKey).slice(0, 8) : 0\n\n    return {\n      privateKey: childKey,\n      childNumber: index,\n      chainCode: hash.slice(64, 128),\n      depth: depth + 1,\n      parentFingerPrint: parseInt(parentFingerPrint, 16),\n      version\n    }\n  } catch (e) {\n    if (!e.message.includes(TWEAK_OUT_OF_RANGE_ERROR)) throw e\n    return fromIndex(key, index + 1, publicKey)\n  }\n}\n\nexport const fromPath = async (key: ExtendedPrivateKey, path: HDPath | string, publicKey?: string) => {\n  if (typeof path === 'string') path = Path.fromString(path)\n  publicKey = publicKey || await toPublicKey(key.privateKey, true)\n  for (const index of path) {\n    key = await fromIndex(key, index, publicKey)\n    publicKey = await toPublicKey(key.privateKey, true)\n  }\n  return key\n}\n\nexport const toHex = (key: ExtendedPrivateKey): string => {\n  const { privateKey, ...rest } = key\n  if (privateKey.length !== 64) throw new Error('Wrong private key length')\n  return dataToHex(rest) + `00${privateKey}`\n}\n\nexport const toString = (\n  hdKey: ExtendedPrivateKey,\n  network: string = 'main'\n): string => getDecoder(network, hdKey.version).encode(toHex(hdKey))\n\nexport const toPublic = async (hdKey: ExtendedPrivateKey, network?: string): Promise<ExtendedPublicKey> => {\n  const { privateKey, version, ...rest } = hdKey\n  const { xpub: { prefix } } = getHDSetting(hdKey.version, network)\n  const publicKey = await toPublicKey(privateKey, true)\n  return { publicKey, version: prefix, ...rest }\n}\n","// @flow\n\nimport { getDecoder, getHDSetting } from '../core/networkInfo.js'\nimport { dataFromHex, dataToHex, XKEY_DEFAULTS, HARDENED, MAX_INDEX, MAX_DEPTH, TWEAK_OUT_OF_RANGE_ERROR } from './common.js'\nimport { sha512Hmac, hash160 } from '../utils/hash.js'\nimport { publicKeyTweakAdd } from '../utils/secp256k1.js'\nimport * as Path from './path.js'\nimport { type HDPath, type ExtendedPublicKey } from '../../types/hd.js'\n\nexport const fromPublic = (key: $Shape<ExtendedPublicKey>, network?: string): ExtendedPublicKey => {\n  const { publicKey, chainCode, ...rest } = key\n  if (!publicKey) throw new Error('Missing public key')\n  if (!chainCode) throw new Error('Missing chainCode')\n  const xKey = { ...XKEY_DEFAULTS, publicKey, chainCode, ...rest }\n  if (!xKey.version) {\n    const { xpub: { prefix } } = getHDSetting('xpub', network)\n    xKey.version = prefix\n  }\n  return xKey\n}\n\nexport const fromHex = (keyHex: string, network?: string): ExtendedPublicKey => {\n  // Get the byte which tells us what type of key we're expecting\n  const headerByte = parseInt(keyHex.slice(90, 92), 16)\n  if (headerByte !== 2 && headerByte !== 3) throw new Error('Wrong public key header')\n\n  return {\n    publicKey: keyHex.slice(90, 156),\n    ...dataFromHex(keyHex, network)\n  }\n}\n\nexport const fromString = (\n  hdKey: string,\n  network: string = 'main'\n): ExtendedPublicKey => {\n  const keyHex = getDecoder(network, hdKey.slice(0, 4)).decode(hdKey)\n  return fromHex(keyHex, network)\n}\n\nexport const fromIndex = async (key: ExtendedPublicKey, index: number): Promise<ExtendedPublicKey> => {\n  try {\n    const { depth, version, publicKey, chainCode } = key\n    if (index >= HARDENED) throw new Error('Cannot derive hardened index from a public key')\n    if (index > MAX_INDEX) throw new Error('Index out of range.')\n    if (depth >= MAX_DEPTH) throw new Error('Depth too high.')\n\n    const tweakKey = publicKey + index.toString(16).padStart(8, '0')\n    const hash = sha512Hmac(chainCode, tweakKey)\n    const childKey = await publicKeyTweakAdd(publicKey, hash.slice(0, 64))\n    const parentFingerPrint = hash160(publicKey).slice(0, 8)\n\n    return {\n      publicKey: childKey,\n      childNumber: index,\n      chainCode: hash.slice(64, 128),\n      depth: depth + 1,\n      parentFingerPrint: parseInt(parentFingerPrint, 16),\n      version\n    }\n  } catch (e) {\n    if (!e.message.includes(TWEAK_OUT_OF_RANGE_ERROR)) throw e\n    return fromIndex(key, index + 1)\n  }\n}\n\nexport const fromPath = async (key: ExtendedPublicKey, path: HDPath | string) => {\n  if (typeof path === 'string') path = Path.fromString(path, 'M')\n  for (const index of path) {\n    key = await fromIndex(key, index)\n  }\n  return key\n}\n\nexport const toHex = (key: ExtendedPublicKey): string => {\n  const { publicKey, ...rest } = key\n  return dataToHex(rest) + publicKey\n}\n\nexport const toString = (\n  hdKey: ExtendedPublicKey,\n  network: string = 'main'\n): string => getDecoder(network, hdKey.version).encode(toHex(hdKey))\n","// @flow\n\nimport {\n  type LoadFunc,\n  type PersistStatus,\n  type SaveFunc\n} from '../../types/utils.js'\n\nexport const persist = (\n  save: SaveFunc,\n  load: LoadFunc | Object,\n  delay: number = 100,\n  cache: Object = {},\n  data: Object = cache,\n  status: PersistStatus = {}\n) => {\n  return new Proxy((Object.assign(() => save(cache), data): any), {\n    apply: async (target, thisArgs, args) => {\n      const updateCache = newCache => {\n        cache = newCache\n        data = newCache\n        for (const key in target) {\n          if (data[key] === undefined) {\n            delete target[key]\n          }\n        }\n        Object.assign(target, newCache)\n      }\n\n      // Try to load the cache from disk in case it never happend before\n      if (!status.loaded) {\n        const rawData = typeof load === 'function' ? await load() : load\n        updateCache({ ...rawData, ...cache })\n        status.loaded = true\n      }\n\n      // Load/Stop the cache based on the argument\n      if (args && args.length) {\n        if (typeof args[0] === 'object') updateCache({ ...args[0] })\n        else if (args[0] === 'stop') {\n          if (status.saving) {\n            clearTimeout(status.saving)\n            status.saving = null\n          }\n          status.changed = false\n          await Reflect.apply(target, target, [])\n          return\n        }\n      }\n\n      // Stop looping in case nothing changed or we already have a save timer\n      if (!status.changed || status.saving) return\n\n      // If something changed, set flags and call save\n      status.changed = false\n\n      // Set save loop after the desired delay\n      status.saving = setTimeout(() => {\n        if (status.saving) {\n          clearTimeout(status.saving)\n          status.saving = null\n        }\n        Reflect.apply(thisArgs, thisArgs, [])\n      }, delay)\n\n      await Reflect.apply(target, target, [])\n    },\n    set: (target: any, prop: string, value: any, receiver: any) => {\n      // Only update/save if the param actually changed\n      if (data[prop] !== value) {\n        Reflect.set(data, prop, value)\n        Reflect.set(target, prop, value)\n        status.changed = true\n        if (!status.saving) Reflect.apply(receiver, receiver, [])\n      }\n      return true\n    },\n    get: (target: any, prop: string) => {\n      if (prop === 'status') return status\n      // Get the value\n      const value = Reflect.get(data, prop)\n      // Return any non object values\n      if (typeof value !== 'object') return value\n      // Create a proxy from the child to trimgger saves on the top parent\n      return persist(save, load, delay, cache, value, status)\n    }\n  })\n}\n","// @flow\n\nimport * as PrivateKey from './src/core/privateKey.js'\nimport * as NetworkInfo from './src/core/networkInfo.js'\nimport * as HDKey from './src/hd/hdKey.js'\nimport * as XPrivateKey from './src/hd/private.js'\nimport * as XPublicKey from './src/hd/public.js'\nimport * as Path from './src/hd/path.js'\nimport * as Base from './src/utils/base.js'\nimport * as Formatter from './src/utils/formatter.js'\nimport * as Hash from './src/utils/hash.js'\nimport * as Persister from './src/utils/persister.js'\nimport * as Require from './src/utils/require.js'\nimport * as Secp256k1 from './src/utils/secp256k1.js'\nimport * as UintArray from './src/utils/uintArray.js'\n\nconst Networks = NetworkInfo.networks\n\nexport const Core = { PrivateKey, Networks, NetworkInfo }\nexport const HD = { XPrivateKey, XPublicKey, HDKey, Path }\nexport const Utils = {\n  Base,\n  Formatter,\n  Hash,\n  Require,\n  Secp256k1,\n  Persister,\n  UintArray\n}\n\nexport * from './types/types.js'\n"],"names":["lazyHandler","activeModule","get","target","prop","receiver","loadedModule","inject","Proxy","args","lazify","unsafeModule","parentModule","injectedModule","loadUnsafe","defaultModule","Object","assign","parentProxy","isHexString","hex","test","toUint8Array","hexString","Error","length","match","bytes","map","byte","parseInt","Uint8Array","fromUint8Array","reduce","str","toString","padStart","hashjs","require","digest","hash","data","uintArray","rawRes","update","resArray","digestHmac","hmac","key","uintKey","hmacHash","sha256","sha512","ripemd160","sha512Hmac","hash256","hash160","ALPHABETS","createCheckSumBase","base","hashFunc","encode","hexStr","checksum","checkHex","slice","decode","baseString","payload","newChecksum","startsWith","createHexEncoder","newBase","a","Buffer","from","check","decoders","alphabet","baseDecoder","basex","bech32","base58","HDPaths","scriptType","xpriv","prefix","stringPrefix","decoder","xpub","address","main","coinType","wif","DefaultHDPath","txHash","sigHash","testnet","createInfo","info","newNetwork","set","mainSet","infoSet","Array","isArray","concat","filter","v","i","s","indexOf","createNetworks","newInfos","networks","network","infos","networkType","partialInfo","name","toLowerCase","Networks","addNetworks","getHDSetting","value","e","purpose","hdPath","setting","find","getDecoder","formatFunction","func","opts","numParams","encoder","results","sync","input","output","cps","newCps","p","paramEncoder","encodeResult","res","param","waitResult","params","result","formatByteSize","originalByteSize","newByteSize","pad","acc","bits","ret","maxNum","push","secp256k1","publicKeyCreate","signatureNormalize","signatureExport","privateKeyTweakAdd","publicKeyTweakAdd","verify","signature","sign","message","privateKey","then","fromWIF","keyHex","compress","toWIF","prefixStr","compressFlag","hexKey","toPublic","toSignature","msg","Sign","publicKey","verified","Verify","HARDENED","SEED","MAX_INDEX","MAX_DEPTH","TWEAK_OUT_OF_RANGE_ERROR","XKEY_DEFAULTS","childNumber","parentFingerPrint","depth","dataToHex","version","chainCode","dataFromHex","isNumeric","fromNumber","index","harden","toNumber","hardened","indexNumber","path","join","JSON","stringify","fromString","root","pathArr","split","pathRoot","shift","fromPrivate","fromSeed","fullKey","seed","fromHex","headerByte","xKey","fromIndex","hardended","toPublicKey","tweakKey","childKey","includes","fromPath","Path","toHex","rest","hdKey","fromPublic","persist","save","load","delay","cache","status","apply","thisArgs","updateCache","newCache","undefined","loaded","rawData","saving","clearTimeout","changed","Reflect","setTimeout","NetworkInfo","Core","PrivateKey","HD","XPrivateKey","XPublicKey","HDKey","Utils","Base","Formatter","Hash","Require","Secp256k1","Persister","UintArray"],"mappings":"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"}